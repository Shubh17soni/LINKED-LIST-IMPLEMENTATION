# LINKED-LIST-IMPLEMENTATION

*COMPANY*: CODTECH IT SOLUTIONS

*NAME*: SHUBH SONI

*INTERN ID*: CT06DH414

*DOMAIN*: C PROGRAMMING INTERN

*DURATION*: 6 WEEKS

*MENTOR*: NEELA SANTOSH

*DESCRIPTION* For this task, I explored the concept of singly linked lists, which was a completely new and interesting topic for me. At the beginning, I had only a basic idea of what a linked list was, but through this task, I got a clear understanding of how it works, how it's structured, and how it's implemented in C programming.

I learned that a linked list is a dynamic data structure made up of nodes. Each node contains two parts: the data and a pointer that points to the next node in the list. Unlike arrays, linked lists are not stored in contiguous memory locations. This makes them more flexible in terms of memory usage, as they can grow and shrink during runtime without requiring memory reallocation or shifting elements.

To implement this, I first created a structure called node using the struct keyword, which had two members: an integer for data and a pointer to the next node. I then used dynamic memory allocation through malloc to create new nodes in memory.One of the key things I understood during this task was how to properly link nodes using pointers so that the list functions as expected.

My program performs three main operations: node creation, deletion, and traversal. In the creation part, I dynamically allocate memory for each new node, take input for its data, and connect it to the list by adjusting the next pointers. For deletion, I learned how to properly free the memory of a node and adjust the links so the list stays connected. In traversal, I move from the head node to the end of the list, printing each node’s data along the way. I also included conditions to handle cases when the list is empty or when the first node needs to be deleted.

One important thing I learned is how crucial it is to manage pointers correctly. Small mistakes like not updating the next pointer or forgetting to check if a pointer is NULL can break the entire program or lead to memory issues. I also understood the significance of debugging—when I encountered logical errors or unexpected outputs, I reviewed my pointer connections and used print statements to trace the flow of the program step by step.

Throughout this task, I used Code::Blocks as my development environment. It helped me write, test, and debug my code efficiently. I learned how to format my code properly, use header files like stdio.h and stdlib.h, and write user-defined functions to keep the program organized.

What I’m most proud of is that I didn’t just copy solutions. I took the time to learn the concepts from scratch, apply logic, make mistakes, and fix them on my own. Now, I feel more confident working with dynamic data structures and pointers. This task has laid a strong foundation for future topics like stacks, queues, and trees.

This was not just about completing a task, but about learning how to think logically and build something from scratch using code. I now understand the real-world use of linked lists and how powerful they can be in managing dynamic data.

*OUTPUT* 
<img width="1102" height="635" alt="Image" src="https://github.com/user-attachments/assets/1d77c946-5585-4640-873d-4d55d31ebac4" />
