# LINKED-LIST-IMPLEMENTATION

*COMPANY*: CODTECH IT SOLUTIONS

*NAME*: SHUBH SONI

*INTERN ID*: CT06DH414

*DOMAIN*: C PROGRAMMING INTERN

*DURATION*: 6 WEEKS

*MENTOR*: NEELA SANTOSH

*DESCRIPTION* For this file handling project in C, I used Code::Blocks 20.03 as my development environment. It’s a lightweight, beginner-friendly IDE that made the entire process of writing, compiling, and testing my code much smoother. I personally found it really efficient for handling C programs, especially those involving file operations, because of its clean interface, helpful features, and built-in compiler support.

This program was focused on demonstrating the core concepts of file handling — specifically creating a file, writing to it, reading from it, and appending additional content without overwriting the existing data. All of this was done using standard file handling functions in C like fopen(), fprintf(), fgetc(), and fclose(), along with different file modes such as "w" for writing, "r" for reading, and "a" for appending.

One of the main reasons I preferred Code::Blocks for this task was the way it simplifies the debugging process. It clearly highlights syntax errors, and the build log immediately shows if something is wrong — which helped me catch and fix issues early. The syntax highlighting and auto-indentation also made my code more readable and organized, especially when dealing with nested logic and file pointer operations. It felt structured and efficient throughout the entire process.

This tool also gave me a better understanding of how file streams work in C. For example, I learned how to handle the end-of-file condition (EOF) correctly, how to work with character-by-character input/output using fgetc() and putchar(), and how to use file modes effectively depending on the task. I also gained clarity on how errors in opening or closing a file should be handled to avoid runtime issues.

What I really appreciated about Code::Blocks was its stability during testing. I could easily run multiple iterations of my code, modify it, and test again without delays or crashes. The workspace management also helped — I could keep my .c file, compiler output, and file content all visible without switching between windows or tools. That really helped keep my workflow clean and productive.

Overall, using Code::Blocks gave me both a smooth coding experience and a better understanding of file handling in C. It’s a great tool for students, interns, or beginners working on foundational programming concepts. This project helped me not just write functional code, but also learn how file input/output works on a deeper level — from creating and modifying files to handling errors and protecting data flow safely. I feel more confident in approaching similar tasks in the future, and I’m glad I could complete this with both understanding and clarity.

